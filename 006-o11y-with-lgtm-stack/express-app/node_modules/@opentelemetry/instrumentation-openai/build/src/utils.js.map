{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../src/utils.ts"],"names":[],"mappings":";;;AAAA;;;;;;;;;;;;;;GAcG;AACH,4CAA0C;AAE1C,8EAG6C;AAE7C;;;;;;;;;;;;;;;GAeG;AACH,SAAgB,UAAU,CACxB,IAAY,EACZ,QAAoB,UAAI;IAExB,MAAM,GAAG,GAAG,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IAC9B,IAAI,GAAG,KAAK,SAAS,IAAI,GAAG,KAAK,EAAE,EAAE;QACnC,OAAO,SAAS,CAAC;KAClB;SAAM,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;QAClC,MAAM,IAAI,KAAK,CACb,0CAA0C,OAAO,GAAG,KAAK,IAAI,IAAI,GAAG,GAAG,CACxE,CAAC;KACH;SAAM;QACL,MAAM,QAAQ,GAAG,GAAG,CAAC,WAAW,EAAE,CAAC;QACnC,IAAI,QAAQ,KAAK,MAAM,EAAE;YACvB,OAAO,IAAI,CAAC;SACb;aAAM,IAAI,QAAQ,KAAK,OAAO,EAAE;YAC/B,OAAO,KAAK,CAAC;SACd;aAAM;YACL,KAAK,CAAC,IAAI,CACR,mDAAmD,IAAI,IAAI,GAAG,YAAY,CAC3E,CAAC;YACF,OAAO,SAAS,CAAC;SAClB;KACF;AACH,CAAC;AAxBD,gCAwBC;AAGD,MAAM,6BAA6B,GAAqB;IACtD,QAAQ,EAAE,GAAG;IACb,OAAO,EAAE,EAAE;CACZ,CAAC;AAEF;;GAEG;AACH,SAAgB,mBAAmB,CACjC,OAA2B,EAC3B,QAAoB,UAAI;IAExB,IAAI,CAAC,OAAO,EAAE;QACZ,OAAO;KACR;IAED,2EAA2E;IAC3E,IAAI,CAAC,CAAC;IACN,IAAI;QACF,CAAC,GAAG,IAAI,GAAG,CAAC,OAAO,CAAC,CAAC;KACtB;IAAC,OAAO,EAAE,EAAE;QACX,gFAAgF;QAChF,mFAAmF;QACnF,KAAK,CAAC,KAAK,CACT,2DAA2D,EAAE,EAAE,CAChE,CAAC;QACF,OAAO;KACR;IAED,OAAO;QACL,CAAC,0CAAmB,CAAC,EAAE,CAAC,CAAC,QAAQ;QACjC,CAAC,uCAAgB,CAAC,EAAE,CAAC,CAAC,IAAI;YACxB,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC;YAChB,CAAC,CAAC,6BAA6B,CAAC,CAAC,CAAC,QAAQ,CAAC;KAC9C,CAAC;AACJ,CAAC;AA3BD,kDA2BC","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { diag } from '@opentelemetry/api';\nimport type { Attributes, DiagLogger } from '@opentelemetry/api';\nimport {\n  ATTR_SERVER_ADDRESS,\n  ATTR_SERVER_PORT,\n} from '@opentelemetry/semantic-conventions';\n\n/**\n * Read a boolean from an environment variable.\n *\n * https://opentelemetry.io/docs/specs/otel/configuration/sdk-environment-variables/#boolean\n *\n * @param {string} name\n * @returns {boolean | undefined}\n *    - Returns `undefined` if the envvar is not set on `process.env` or is\n *      the empty string. This indicates that no explicit value was given,\n *      which may be a useful distinction from an explicit `false` for callers.\n *    - Returns `true` iff the envvar value is the string \"true\" (case-insensitive).\n *    - Returns `false`, iff the envvar value is the string \"false\" (case-insensitive).\n *    - Otherwise, it `diag.warn()`s about the invalid value and returns\n *      `undefined` as a (falsey) fallback.\n * @throws if the envvar value is set and is not a string\n */\nexport function getEnvBool(\n  name: string,\n  diag_: DiagLogger = diag\n): boolean | undefined {\n  const val = process.env[name];\n  if (val === undefined || val === '') {\n    return undefined;\n  } else if (typeof val !== 'string') {\n    throw new Error(\n      `invalid type for environment variable: ${typeof val} (${name}=${val})`\n    );\n  } else {\n    const valLower = val.toLowerCase();\n    if (valLower === 'true') {\n      return true;\n    } else if (valLower === 'false') {\n      return false;\n    } else {\n      diag_.warn(\n        `invalid boolean value for environment variable: ${name}=${val}; ignoring`\n      );\n      return undefined;\n    }\n  }\n}\n\ntype PortFromProtocol = { [key: string]: number };\nconst SERVER_PORT_FROM_URL_PROTOCOL: PortFromProtocol = {\n  'https:': 443,\n  'http:': 80,\n};\n\n/**\n * Return span/metric attributes from the given OpenAI client baseURL.\n */\nexport function getAttrsFromBaseURL(\n  baseURL: string | undefined,\n  diag_: DiagLogger = diag\n): Attributes | undefined {\n  if (!baseURL) {\n    return;\n  }\n\n  // TODO: would be nice to LRU cache this, but probably not significant perf\n  let u;\n  try {\n    u = new URL(baseURL);\n  } catch (ex) {\n    // Note: We should never get to this point as openai should crash prior to this.\n    // Even if it did, instrumentation will still work except lacking these attributes.\n    diag_.debug(\n      `could not determine server.{address,port} from baseURL: ${ex}`\n    );\n    return;\n  }\n\n  return {\n    [ATTR_SERVER_ADDRESS]: u.hostname,\n    [ATTR_SERVER_PORT]: u.port\n      ? Number(u.port)\n      : SERVER_PORT_FROM_URL_PROTOCOL[u.protocol],\n  };\n}\n"]}